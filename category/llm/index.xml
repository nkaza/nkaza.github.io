<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>llm | Nikhil Kaza</title>
    <link>https://nkaza.github.io/category/llm/</link>
      <atom:link href="https://nkaza.github.io/category/llm/index.xml" rel="self" type="application/rss+xml" />
    <description>llm</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>© 2018-2025 Nikhil Kaza</copyright><lastBuildDate>Thu, 31 Jul 2025 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://nkaza.github.io/media/icon_hu1ca6a6912ef6c300619228a995d3f134_46128_512x512_fill_lanczos_center_3.png</url>
      <title>llm</title>
      <link>https://nkaza.github.io/category/llm/</link>
    </image>
    
    <item>
      <title>Possibilities and Pitfalls of Large Language Models.</title>
      <link>https://nkaza.github.io/post/possibilities-and-pitfalls-of-large-language-models/</link>
      <pubDate>Thu, 31 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://nkaza.github.io/post/possibilities-and-pitfalls-of-large-language-models/</guid>
      <description>


&lt;div id=&#34;introduction&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;This post was last updated on 2025-08-07&lt;/p&gt;
&lt;p&gt;Large Language Models (LLMs) represent a class of artificial intelligence systems that have fundamentally transformed natural language processing and generation. These neural networks, trained on vast corpora of text data, demonstrate remarkable capabilities in mimicking the understanding context, generating coherent(ish) responses, and performing complex reasoning tasks across diverse domains.&lt;/p&gt;
&lt;p&gt;At their core, most modern LLMs are built upon the &lt;strong&gt;transformer architecture&lt;/strong&gt;, introduced in the seminal paper &lt;a href=&#34;https://arxiv.org/abs/1706.03762&#34;&gt;“Attention Is All You Need”&lt;/a&gt; by Vaswani et al. in 2017. The transformer’s key innovation lies in its self-attention mechanism, which allows the model to weigh the importance of different words in a sequence when processing each token. This parallel processing capability offers significant computational advantages over previous sequential architectures like RNNs and LSTMs.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/Transformers.png&#34; /&gt;
(Generated by Gemini)&lt;/p&gt;
&lt;p&gt;The transformer consists of encoder and decoder blocks, each containing multi-head self-attention layers and feed-forward networks. However, most contemporary LLMs adopt variations of this base architecture, leading to distinct model families with different strengths and applications.&lt;/p&gt;
&lt;p&gt;LLM development typically follows a multi-stage process. &lt;strong&gt;Pre-training&lt;/strong&gt; involves unsupervised learning on massive text corpora, where models learn to predict next tokens and develop broad linguistic understanding. This is why many of the models are really bad at langauges other than English. &lt;strong&gt;Fine-tuning&lt;/strong&gt; adapts pre-trained models to specific tasks or domains through supervised learning on curated datasets.&lt;/p&gt;
&lt;div id=&#34;architectural-variations&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Architectural Variations&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Encoder-only models&lt;/strong&gt;, such as &lt;a href=&#34;https://arxiv.org/abs/1810.04805&#34;&gt;BERT&lt;/a&gt; (Bidirectional Encoder Representations from Transformers), excel at understanding and encoding text representations. These models process input bidirectionally, making them particularly effective for tasks like sentiment analysis, question answering, and text classification where understanding context from both directions is crucial.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Decoder-only models&lt;/strong&gt; represent the dominant paradigm for generative LLMs. Models like &lt;a href=&#34;https://openai.com/research/language-unsupervised&#34;&gt;GPT&lt;/a&gt; (Generative Pre-trained Transformer), &lt;a href=&#34;https://www.anthropic.com/claude&#34;&gt;Claude&lt;/a&gt;, and &lt;a href=&#34;https://arxiv.org/abs/2302.13971&#34;&gt;LLaMA&lt;/a&gt; use causal self-attention, processing text autoregressively from left to right. This architecture proves highly effective for text generation, completion, and conversational AI applications.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Encoder-decoder models&lt;/strong&gt;, including &lt;a href=&#34;https://arxiv.org/abs/1910.10683&#34;&gt;T5&lt;/a&gt; (Text-to-Text Transfer Transformer) and &lt;a href=&#34;https://arxiv.org/abs/1910.13461&#34;&gt;BART&lt;/a&gt;, combine both components and excel at sequence-to-sequence tasks like translation, summarization, and text transformation.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;scale-and-emergent-capabilities&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Scale and Emergent Capabilities&lt;/h3&gt;
&lt;p&gt;The “large” in Large Language Models refers to their unprecedented scale across multiple dimensions: parameter count, training data volume, and computational requirements. Modern LLMs contain billions to trillions of parameters, with models like &lt;a href=&#34;https://arxiv.org/abs/2303.08774&#34;&gt;GPT-4&lt;/a&gt; and &lt;a href=&#34;https://arxiv.org/abs/2204.02311&#34;&gt;PaLM&lt;/a&gt; demonstrating that increased scale often leads to emergent capabilities not present in smaller models.&lt;/p&gt;
&lt;p&gt;These emergent properties include where models can adapt to new tasks with minimal examples, chain-of-thought reasoning for complex problem-solving, and cross-modal understanding when trained on multimodal data. The scaling hypothesis, which I do not subscribe to, suggests that many AI capabilities may emerge naturally from increased model size and training data, though this relationship isn’t always predictable.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;use-case&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Use Case&lt;/h2&gt;
&lt;p&gt;LLMs have found applications across a wide range of domains and in particular for planning purposes they can be used for extracting data from unstructured texts. In this tutorial, I am going to demonstrate it on an example dataset scraped from the &lt;a href=&#34;https://starw1.ncuc.gov/NCUC/page/Dockets/portal.aspx&#34;&gt;North Carolina Utilities Commission website&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;“Pursuant to G.S. 62-110.1(g), any person who seeks to construct an electric generating facility in North Carolina, and is exempt from the requirement to obtain a certificate of public convenience and necessity, is required to file this [ROPC] form and a notice of completion of the construction of the facility.”&lt;/p&gt;
&lt;p&gt;Small scale (&amp;lt;1 MW) solar power plants (rooftop or ground mounted) fall under this category. This &lt;a href=&#34;https://www.dropbox.com/scl/fi/nreu2frrsqw1soqbk1y6b/dockets_fileurls_unique.csv?rlkey=xz3xa33c8he5es3qd1hdkk5fn&amp;amp;dl=0&#34;&gt;dataset&lt;/a&gt; consists of all the unique records for ROPC until mid May 2024. Note that these do not necessarily mean that the plant is completed or operational.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)
library(here)

ropc_data &amp;lt;- here(&amp;quot;tutorials_datasets&amp;quot;, &amp;quot;llms&amp;quot;, &amp;quot;dockets_fileurls_unique.csv&amp;quot;) %&amp;gt;%
  read_csv(show_col_types = FALSE) %&amp;gt;%
  mutate(across(everything(), as.character))

set.seed(123)  # For reproducibility
test_data &amp;lt;- ropc_data %&amp;gt;%
  sample_n(5)

test_data$Description
# [1] &amp;quot;ROPC for 0.00609MW Solar Located at 7145 Streamhaven Drive, Harrisburg, NC 28075 in Cabarrus County\nFiles:&amp;quot;
# [2] &amp;quot;ROPC for 5.2kW Solar Located at 179 Lars Lane, Garner, NC 27529 in Johnston County\nFiles:&amp;quot;                 
# [3] &amp;quot;ROPC for 10.85kW Solar System Located at 8804 Amerjack Ct. Raleigh, NC 27603 in Wake County\nFiles:&amp;quot;        
# [4] &amp;quot;ROPC for 10.88 kW Solar Located at 46 Sunnyfield Ct Benson NC 27504 in Johnston County\nFiles:&amp;quot;             
# [5] &amp;quot;Amended ROPC\nFiles:&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that the description column in the dataset contains unstructured text that describes the solar power plant including the street address information that can be used for &lt;a href=&#34;https://nkaza.github.io/post/matching-messy-texts/&#34;&gt;geocoding&lt;/a&gt;. The goal is to extract structured information from this text using a Large Language Model (LLM). We will first try to do this with an Open Source and free model called &lt;a href=&#34;https://ollama.com/&#34;&gt;Ollama&lt;/a&gt; and then with a commercial model called &lt;a href=&#34;https://www.anthropic.com/claude&#34;&gt;Anthropic’s Claude&lt;/a&gt;.&lt;/p&gt;
&lt;div id=&#34;using-local-llms&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Using Local LLMs&lt;/h3&gt;
&lt;p&gt;Ollama is a platform that allows you to run large language models locally on your machine. It provides a simple command-line interface to download and run models, making it easy to experiment with LLMs without needing an internet connection or API keys.&lt;/p&gt;
&lt;p&gt;To use Ollama, you need to install it on your machine. You can find installation instructions on the &lt;a href=&#34;https://ollama.com/docs/installation&#34;&gt;Ollama website&lt;/a&gt;. Once installed and running, you can download models using the &lt;code&gt;ollmar&lt;/code&gt; package. For example, to download the &lt;code&gt;Llama 3.2 model&lt;/code&gt;, you would run:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ollamar)
ollamar::pull(&amp;quot;llama3.2&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see all the models you have downloaded locally by using &lt;code&gt;list_models()&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ollamar::list_models()
#              name    size parameter_size quantization_level            modified
# 1 llama3.1:latest  4.9 GB           8.0B             Q4_K_M 2025-07-30T13:43:47
# 2 llama3.2:latest    2 GB           3.2B             Q4_K_M 2025-07-30T14:02:07
# 3 llama3.3:latest 42.5 GB          70.6B             Q4_K_M 2025-07-30T13:33:53&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Notice that llama 3.3 is substantially larger than llama 3.2, and thus requires more memory to run.
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Once the model is downloaded, you can interact with it using the &lt;code&gt;ellmer&lt;/code&gt; package in R. The &lt;code&gt;ellmer&lt;/code&gt; package provides a convenient interface for interacting with various LLMs, including both open-source and commercial models. It allows you to send prompts to the models and receive structured responses.&lt;/p&gt;
&lt;p&gt;First initialise the model.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ellmer)
library(jsonlite)

ollama_chat &amp;lt;- chat_ollama(
  model = &amp;quot;llama3.2&amp;quot;,
  system_prompt = &amp;quot;You are an expert at extracting structured information from unstructured text. Always return valid JSON.&amp;quot;,
)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;prompt-engineering&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Prompt Engineering&lt;/h3&gt;
&lt;p&gt;Prompt engineering has emerged as a critical skill for effectively leveraging LLMs, involving the strategic design and refinement of input instructions to elicit desired model behaviours and outputs. The quality and structure of prompts significantly influence model performance.&lt;/p&gt;
&lt;p&gt;
&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/7wizt0K4EBA&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Key rules of thumb:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Be explicit and specific in your instructions rather than relying on implicit understanding&lt;/li&gt;
&lt;li&gt;Provide concrete examples of desired outputs when possible (few-shot prompting)&lt;/li&gt;
&lt;li&gt;Breaking complex tasks into smaller, sequential steps to enable clearer reasoning.&lt;/li&gt;
&lt;li&gt;Assign specific roles or personas when relevant (“act as a data scientist analysing…”), and iterate on your prompts based on initial outputs.&lt;/li&gt;
&lt;li&gt;Test your prompts across different scenarios and edge cases to ensure robustness, as small changes in wording can sometimes produce dramatically different results from the same model.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;
extraction_prompt &amp;lt;- &amp;quot;
Extract the following information from the given text and return ONLY valid JSON, no markdown:

{
  \&amp;quot;street_address\&amp;quot;: \&amp;quot;extracted street address or null\&amp;quot;,
  \&amp;quot;city\&amp;quot;: \&amp;quot;extracted city or null\&amp;quot;, 
  \&amp;quot;state\&amp;quot;: \&amp;quot;extracted state abbreviation or null\&amp;quot;,
  \&amp;quot;zip_code\&amp;quot;: \&amp;quot;extracted ZIP code or null\&amp;quot;,
  \&amp;quot;capacity\&amp;quot;: \&amp;quot;extracted capacity along with power units in W, kiloWatts (KW), MegaWatts (MW) or null. \&amp;quot;
  \&amp;quot;type\&amp;quot;: \&amp;quot;AC or DC or null\&amp;quot;

}

Rules:
- Only extract information that is clearly present
- Return null for missing information. Do not make up values
- Ensure valid JSON format
- No text outside the JSON response

Text to analyze: &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s try and extract data for one of the records in the dataset.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;
full_prompt &amp;lt;- paste0(extraction_prompt, test_data$Description[1])


response &amp;lt;- tryCatch({
    ollama_chat$chat(full_prompt, echo = FALSE)
  }, error = function(e) {
    message(&amp;quot;Error: &amp;quot;, e$message)
    return(NULL)
  })


  parsed_response &amp;lt;- tryCatch({
    fromJSON(response) %&amp;gt;% 
      map(~ ifelse(is.null(.x), NA, .x))
  }, error = function(e) {
    list(street_address = NA, city = NA, state = NA, zip_code = NA, capacity = NA, type = NA)
  }) %&amp;gt;%
    as_tibble()
  
print(cbind(Docket_Name = test_data$Docket_Name[1], parsed_response))
#                            Docket_Name         street_address       city state
# 1 a2527260-ba3c-48a4-b511-75cd95455530 7145 Streamhaven Drive Harrisburg    NC
#   zip_code capacity type
# 1    28075       NA   AC&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Exercise:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rerun this code multiple times and see if you get the same results. If not, why do you think that is?&lt;/li&gt;
&lt;li&gt;Re-engineer the prompt to extract the capacity in kiloWatts (kW) only and perform any necessary conversions.&lt;/li&gt;
&lt;li&gt;Figure out why is it necessary to convert the NULLs to NAs. What happens when you don’t?&lt;/li&gt;
&lt;li&gt;Change the model to Llama 3.1 and see if you get the same results. If not, why do you think that is? What about Llama 3.3? Does it work? If not, why do you think that is?&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;It is more straightforward to extract structured information using &lt;code&gt;ellmer&lt;/code&gt; without resorting to &lt;code&gt;jsonlite&lt;/code&gt;. But first we need to define the structure of the data we want to extract. This is done using the &lt;code&gt;type_object&lt;/code&gt; function from &lt;code&gt;ellmer&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;
type_solar &amp;lt;- type_object(street_address = type_string(required = FALSE), city = type_string(required = FALSE), 
                          state = type_string(&amp;quot;2 letter US state abbreviation&amp;quot;, required = FALSE), zip_code = type_string(&amp;quot;5 digit US ZIP code&amp;quot;, required = FALSE), 
                          capacity = type_string(&amp;quot;in any power units such as W, KW or MW&amp;quot;, required = FALSE), capacity_type = type_string(&amp;quot;AC or DC&amp;quot;, required = FALSE))


ollama_chat$chat_structured(full_prompt, type = type_solar) %&amp;gt;%
  as_tibble() %&amp;gt;%
  print()
# # A tibble: 1 × 6
#   street_address         city       state zip_code capacity capacity_type
#   &amp;lt;chr&amp;gt;                  &amp;lt;chr&amp;gt;      &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;        
# 1 7145 Streamhaven Drive Harrisburg NC    28075    &amp;quot;&amp;quot;       DC&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;/p&gt;
&lt;p&gt;Note that the model does not recognise the &lt;code&gt;capacity_type&lt;/code&gt; as AC or DC. It does not understand the notion of types of electricity and their designations. In the previous code chunks, it hallucinated the value as AC, even though the text did not specify it and we explictly asked it not to hallucinate. This is a &lt;em&gt;very&lt;/em&gt; common problem with LLMs. You should treat the output from LLMs with extreme caution.&lt;/p&gt;
&lt;p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Exercise:&lt;/strong&gt;
* Rewrite the code to extract the data for 100 random records in the dataset. How long does it take?&lt;/p&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;div id=&#34;commercial-models&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Commercial Models&lt;/h3&gt;
&lt;p&gt;To use commercial LLMs such as Claude or GPT, you need to acquire API keys from the respective providers. These models often provide more advanced capabilities and better performance than open-source models, but they come with associated costs. You can set the API key in your R environment using the &lt;code&gt;Sys.setenv()&lt;/code&gt; function. For example, to set the API key for Anthropic’s Claude, you would do:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Sys.setenv(ANTHROPIC_API_KEY = &amp;quot;.......&amp;quot;) # Replace with your actual API key&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    &lt;/p&gt;
&lt;p&gt;Commercial LLMs such as Claude, and GPT require you to pay for them. Please acquire your own API keys. You should expect to pay for the API calls you make. Thus, this post only uses very small dataset. Expect to spend some money if you want to follow along.&lt;/p&gt;
&lt;p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;The process then in very similar to using Ollama. You first need to initialise the model with the &lt;code&gt;ellmer&lt;/code&gt; package.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;claude_chat &amp;lt;- chat_anthropic(
  model = &amp;quot;claude-3-5-sonnet-20241022&amp;quot;,  # or &amp;quot;claude-3-opus-20240229&amp;quot;, &amp;quot;claude-3-haiku-20240307&amp;quot;
  api_key = Sys.getenv(&amp;quot;ANTHROPIC_API_KEY&amp;quot;),
  system_prompt = &amp;quot;You are an expert at extracting structured information from unstructured text. Always return valid JSON.&amp;quot;,
  params = list(max_tokens = 1000,temperature = 0.1)  # Low temperature for consistent extraction
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Fortunately, with Claude you can do batch processing of prompts, which is very useful for large datasets. The &lt;code&gt;batch_chat_structured&lt;/code&gt; function allows you to send multiple prompts at once and receive structured responses in a single call.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;prompts_ropc &amp;lt;- map(test_data$Description, function(s){paste0(extraction_prompt, s)})

batch_chat_structured(claude_chat, 
                      prompts_ropc, 
                      wait = TRUE, 
                      type = type_solar, 
                      path = &amp;#39;solar.json&amp;#39;, 
                      include_cost = TRUE)

# Description:df [5 × 7]
# street_address	city	state	zip_code	capacity	capacity_type	cost
# 7145 Streamhaven Drive	Harrisburg	NC	28075	0.00609MW	NA	0.003840
# 179 Lars Lane	Garner	NC	27529	5.2KW	NA	0.003759
# 8804 Amerjack Ct	Raleigh	NC	27603	10.85KW	NA	0.003870
# 46 Sunnyfield Ct	Benson	NC	27504	10.88 kW	NA	0.003843
# NA	NA	NA	NA	NA	NA	0.003201
5 rows
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Exercise:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Compare the differences in the output between Ollama and Claude. Can you generalise?&lt;/li&gt;
&lt;li&gt;Try a different model like chat_mistral() or chat_gemini() and see if you get the same results. If not, why do you think that is?&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;div id=&#34;more-complicated-chunks&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;More complicated chunks&lt;/h3&gt;
&lt;p&gt;There is no reason to presume that LLMs can only read and interpret simple texts. You can use to extract structured information from more complicated texts such as tables, or even pdfs with varying degrees of efficiency. Let’s try Llama on a small subset of &lt;a href=&#34;https://www.dropbox.com/scl/fo/7phnvvdbwwxkfkqz7vdk5/AApenea-EDXSWnQ1uk7zZRU?rlkey=fj2izokc8c0g9c7nnql8altpk&amp;amp;dl=0&#34;&gt;pdfs&lt;/a&gt; that include actual ROPC submissions.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;paths = here(&amp;quot;tutorials_datasets&amp;quot;, &amp;quot;llms&amp;quot;, &amp;quot;pdfs&amp;quot;) %&amp;gt;%
  list.files(full.names = T)

extraction_prompt3 &amp;lt;- &amp;quot;
Extract the following information in each of the pdf files and return ONLY valid JSON, no markdown:

{
  \&amp;quot;owner_type\&amp;quot;: \&amp;quot;Individual or Corportation or Partnership or null\&amp;quot;,
  \&amp;quot;agent\&amp;quot;: \&amp;quot;extracted agent name or null\&amp;quot;,
  \&amp;quot;agent_business_address\&amp;quot;: \&amp;quot;extracted address or null\&amp;quot;, 
  \&amp;quot;site_address\&amp;quot;: \&amp;quot;extracted E911 street address or null\&amp;quot;,
  \&amp;quot;gps_coords\&amp;quot;: \&amp;quot;GPS coordinates or null\&amp;quot;,
  \&amp;quot;capacity\&amp;quot;: \&amp;quot;extracted capacity along with power units in W, kiloWatts (KW), MegaWatts (MW) or null. \&amp;quot;
  \&amp;quot;annual_sales\&amp;quot;: \&amp;quot;extracted projected annual sales or null\&amp;quot;

}

Rules:
- Only extract information that is clearly present
- Return null for missing information. Do not make up values
- Ensure valid JSON format
- Be thorough - check the entire document for relevant information
&amp;quot;

claude_chat$chat(extraction_prompt3, content_pdf_file(paths[1]), echo =FALSE) %&amp;gt;%
                   fromJSON() %&amp;gt;%
                        map(~ ifelse(is.null(.x), NA, .x)) %&amp;gt;%
                   as_tibble()

# # A tibble: 1 × 7
#  owner_type agent                agent_business_address             site_address gps_coords capacity annual_sales
#  &amp;lt;chr&amp;gt;      &amp;lt;chr&amp;gt;                &amp;lt;chr&amp;gt;                              &amp;lt;chr&amp;gt;        &amp;lt;lgl&amp;gt;      &amp;lt;chr&amp;gt;    &amp;lt;lgl&amp;gt;       
#1 Individual Nexus Energy Systems 10964 Richardson Road, Ashland, V… 101 Bunker … NA         4.93 kW… NA    
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Exercise:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Do this for all the pdfs in the folder. How long does it take? How much does it cost?&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The emergence of LLMs has fundamentally transformed the landscape of data extraction from unstructured sources. Where traditional approaches relied on rigid patterns, complex rules, and brittle parsing logic, LLMs bring contextual understanding, semantic awareness, and remarkable adaptability to the challenge of converting messy, real-world text into clean, actionable data.&lt;/p&gt;
&lt;p&gt;However, these are not without challenges. The non-deterministic nature of LLMs means that outputs may vary between runs, requiring careful validation and quality control processes. This poses serious problems for reproducibility. In addition, costs can accumulate quickly with large-scale operations, particularly when using cloud-based APIs. Privacy and security concerns demand thoughtful consideration, especially when processing sensitive documents. And while LLMs are remarkably capable, they are not infallible—human oversight remains essential for critical applications.&lt;/p&gt;
&lt;p&gt;The most successful implementations combine the strengths of LLMs with complementary technologies: using traditional preprocessing to clean and structure input data, implementing robust validation pipelines to catch errors, and designing human-in-the-loop workflows for quality assurance.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
